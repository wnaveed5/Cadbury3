{"ast":null,"code":"// AI provider hook - uses ChatGPT API directly\n// Set REACT_APP_OPENAI_API_KEY in your .env file to keep the key secure\n\nexport function useAIProvider() {\n  const apiKey = process.env.REACT_APP_OPENAI_API_KEY;\n  async function getFieldSuggestions(payload) {\n    if (!apiKey) {\n      throw new Error('OpenAI API key not configured. Set REACT_APP_OPENAI_API_KEY in your .env file');\n    }\n    try {\n      var _payload$companyField, _payload$purchaseOrde, _payload$vendorFields, _payload$shipToFields, _content;\n      // Build reusable messages for both chat and fallback calls\n      const messages = [{\n        role: 'system',\n        content: `You are a helpful assistant that fills out purchase order forms. \n              Analyze the provided fields and return realistic, business-appropriate values.\n              Return ONLY a JSON object with field IDs as keys and suggested values as strings.\n              Example: {\"company-name\": \"Acme Corporation\", \"po-number\": \"PO-2024-001\"}`\n      }, {\n        role: 'user',\n        content: `Generate realistic purchase order data in JSON format. Include:\n\nCompany: ${(_payload$companyField = payload.companyFields) === null || _payload$companyField === void 0 ? void 0 : _payload$companyField.map(f => f.id).join(', ')}\nPO: ${(_payload$purchaseOrde = payload.purchaseOrderFields) === null || _payload$purchaseOrde === void 0 ? void 0 : _payload$purchaseOrde.map(f => f.id).join(', ')}\nVendor: ${(_payload$vendorFields = payload.vendorFields) === null || _payload$vendorFields === void 0 ? void 0 : _payload$vendorFields.map(f => f.id).join(', ')}\nShipTo: ${(_payload$shipToFields = payload.shipToFields) === null || _payload$shipToFields === void 0 ? void 0 : _payload$shipToFields.map(f => f.id).join(', ')}\nShipping: requisitioner, shipVia, fob, shippingTerms\nLineItems: itemNumber, description, qty, rate, amount (3 items)\nTotals: subtotal, tax, shipping, other, total\nComments: comments, contactInfo\n\nReturn ONLY valid JSON with field IDs as keys.`\n      }];\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          model: 'gpt-3.5-turbo',\n          messages,\n          temperature: 1,\n          // Force JSON-only output\n          response_format: {\n            type: 'json_object'\n          },\n          // Allow more output to avoid truncation\n          max_completion_tokens: 3000\n        })\n      });\n      if (!response.ok) {\n        var _errorData$error;\n        const errorData = await response.json();\n        throw new Error(`OpenAI API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      }\n      const data = await response.json();\n      console.debug('ðŸ§ª OpenAI chat data:', data);\n\n      // Extract content across possible API response shapes\n      const extractContent = payload => {\n        var _payload$choices, _payload$choices$, _payload$choices$$mes, _payload$choices2, _payload$choices2$, _payload$choices2$$me;\n        const cc = payload === null || payload === void 0 ? void 0 : (_payload$choices = payload.choices) === null || _payload$choices === void 0 ? void 0 : (_payload$choices$ = _payload$choices[0]) === null || _payload$choices$ === void 0 ? void 0 : (_payload$choices$$mes = _payload$choices$.message) === null || _payload$choices$$mes === void 0 ? void 0 : _payload$choices$$mes.content;\n        if (typeof cc === 'string' && cc.trim()) return cc;\n        // Some models may return parsed JSON when response_format is json_object\n        const parsedField = payload === null || payload === void 0 ? void 0 : (_payload$choices2 = payload.choices) === null || _payload$choices2 === void 0 ? void 0 : (_payload$choices2$ = _payload$choices2[0]) === null || _payload$choices2$ === void 0 ? void 0 : (_payload$choices2$$me = _payload$choices2$.message) === null || _payload$choices2$$me === void 0 ? void 0 : _payload$choices2$$me.parsed;\n        if (parsedField && typeof parsedField === 'object') return JSON.stringify(parsedField);\n        if (typeof (payload === null || payload === void 0 ? void 0 : payload.output_text) === 'string' && payload.output_text.trim()) {\n          return payload.output_text;\n        }\n        const outputArray = payload === null || payload === void 0 ? void 0 : payload.output;\n        if (Array.isArray(outputArray) && outputArray.length > 0) {\n          // Search all items and parts for any text\n          for (const item of outputArray) {\n            const parts = item === null || item === void 0 ? void 0 : item.content;\n            if (Array.isArray(parts)) {\n              for (const p of parts) {\n                if (typeof (p === null || p === void 0 ? void 0 : p.text) === 'string' && p.text.trim()) return p.text;\n              }\n            }\n          }\n        }\n        const topContent = payload === null || payload === void 0 ? void 0 : payload.content;\n        if (Array.isArray(topContent)) {\n          const textPart = topContent.find(p => typeof (p === null || p === void 0 ? void 0 : p.text) === 'string' && p.text.trim());\n          if (textPart !== null && textPart !== void 0 && textPart.text) return textPart.text;\n        }\n        return undefined;\n      };\n      let content = extractContent(data);\n      console.debug('ðŸ§ª Extracted content after chat:', typeof content, (_content = content) !== null && _content !== void 0 && _content.slice ? content.slice(0, 200) : content);\n      if (!content) {\n        var _content2;\n        // Fallback to Responses API once\n        const respFallback = await fetch('https://api.openai.com/v1/responses', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${apiKey}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            model: 'gpt-3.5-turbo',\n            // Send structured messages for better adherence\n            input: [{\n              role: 'system',\n              content: messages[0].content\n            }, {\n              role: 'user',\n              content: messages[1].content\n            }],\n            // Force JSON-only output\n            response_format: {\n              type: 'json_object'\n            },\n            max_output_tokens: 1500\n          })\n        });\n        if (!respFallback.ok) {\n          var _errorData$error2;\n          const errorData = await respFallback.json();\n          throw new Error(`OpenAI API error: ${((_errorData$error2 = errorData.error) === null || _errorData$error2 === void 0 ? void 0 : _errorData$error2.message) || respFallback.statusText}`);\n        }\n        const dataFallback = await respFallback.json();\n        console.debug('ðŸ§ª OpenAI responses data (fallback):', dataFallback);\n        content = extractContent(dataFallback);\n        console.debug('ðŸ§ª Extracted content after fallback:', typeof content, (_content2 = content) !== null && _content2 !== void 0 && _content2.slice ? content.slice(0, 200) : content);\n      }\n      if (!content) {\n        throw new Error('No response content from OpenAI');\n      }\n\n      // Parse the JSON response, tolerate code fences or extra text, and filter to known field IDs\n      try {\n        // Remove possible Markdown code fences\n        let cleaned = content.trim();\n        if (cleaned.startsWith('```')) {\n          cleaned = cleaned.replace(/^```(?:json)?\\s*/i, '').replace(/```$/i, '').trim();\n        }\n        let parsed;\n        try {\n          parsed = JSON.parse(cleaned);\n        } catch (innerErr) {\n          // Try extracting the first JSON object if extra prose is present\n          const firstBrace = cleaned.indexOf('{');\n          const lastBrace = cleaned.lastIndexOf('}');\n          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n            const maybeJson = cleaned.slice(firstBrace, lastBrace + 1);\n            parsed = JSON.parse(maybeJson);\n          } else {\n            throw innerErr;\n          }\n        }\n\n        // Build allowlist of known field IDs and a lookup by normalized label\n        const allFields = [...(payload.companyFields || []), ...(payload.purchaseOrderFields || []), ...(payload.vendorFields || []), ...(payload.shipToFields || []), ...(payload.shippingFields || [])];\n        const allowedIds = allFields.map(f => f.id);\n        const normalize = s => String(s || '').toLowerCase().replace(/[`\"'â€™]/g, '').replace(/\\s+/g, ' ').trim().replace(/[^a-z0-9]+/g, '');\n        const labelToId = Object.fromEntries(allFields.map(f => [normalize(f.label || f.id), f.id]));\n        const coerceToString = v => {\n          if (typeof v === 'string') return v;\n          if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n          if (v && typeof v === 'object') {\n            if (typeof v.value === 'string') return v.value;\n            if (typeof v.text === 'string') return v.text;\n          }\n          return undefined;\n        };\n        const suggestions = {};\n        for (const [rawKey, rawVal] of Object.entries(parsed || {})) {\n          const value = coerceToString(rawVal);\n          if (value === undefined) continue;\n\n          // direct id match\n          if (allowedIds.includes(rawKey)) {\n            suggestions[rawKey] = value;\n            continue;\n          }\n\n          // label-based or fuzzy match\n          const normalizedKey = normalize(rawKey);\n          const maybeId = labelToId[normalizedKey];\n          if (maybeId && allowedIds.includes(maybeId)) {\n            suggestions[maybeId] = value;\n          }\n        }\n        return {\n          suggestions\n        };\n      } catch (parseError) {\n        console.error('Failed to parse OpenAI response:', content);\n        throw new Error('Invalid JSON response from AI - please try again');\n      }\n    } catch (error) {\n      console.error('OpenAI API call failed:', error);\n      throw error;\n    }\n  }\n  return {\n    getFieldSuggestions\n  };\n}","map":{"version":3,"names":["useAIProvider","apiKey","process","env","REACT_APP_OPENAI_API_KEY","getFieldSuggestions","payload","Error","_payload$companyField","_payload$purchaseOrde","_payload$vendorFields","_payload$shipToFields","_content","messages","role","content","companyFields","map","f","id","join","purchaseOrderFields","vendorFields","shipToFields","response","fetch","method","headers","body","JSON","stringify","model","temperature","response_format","type","max_completion_tokens","ok","_errorData$error","errorData","json","error","message","statusText","data","console","debug","extractContent","_payload$choices","_payload$choices$","_payload$choices$$mes","_payload$choices2","_payload$choices2$","_payload$choices2$$me","cc","choices","trim","parsedField","parsed","output_text","outputArray","output","Array","isArray","length","item","parts","p","text","topContent","textPart","find","undefined","slice","_content2","respFallback","input","max_output_tokens","_errorData$error2","dataFallback","cleaned","startsWith","replace","parse","innerErr","firstBrace","indexOf","lastBrace","lastIndexOf","maybeJson","allFields","shippingFields","allowedIds","normalize","s","String","toLowerCase","labelToId","Object","fromEntries","label","coerceToString","v","value","suggestions","rawKey","rawVal","entries","includes","normalizedKey","maybeId","parseError"],"sources":["/Users/waleed/Documents/GitHub/Cadbury3/src/hooks/useAIProvider.js"],"sourcesContent":["// AI provider hook - uses ChatGPT API directly\n// Set REACT_APP_OPENAI_API_KEY in your .env file to keep the key secure\n\nexport function useAIProvider() {\n  const apiKey = process.env.REACT_APP_OPENAI_API_KEY;\n\n  async function getFieldSuggestions(payload) {\n    if (!apiKey) {\n      throw new Error('OpenAI API key not configured. Set REACT_APP_OPENAI_API_KEY in your .env file');\n    }\n\n    try {\n      // Build reusable messages for both chat and fallback calls\n      const messages = [\n        {\n          role: 'system',\n          content: `You are a helpful assistant that fills out purchase order forms. \n              Analyze the provided fields and return realistic, business-appropriate values.\n              Return ONLY a JSON object with field IDs as keys and suggested values as strings.\n              Example: {\"company-name\": \"Acme Corporation\", \"po-number\": \"PO-2024-001\"}`\n        },\n        {\n          role: 'user',\n          content: `Generate realistic purchase order data in JSON format. Include:\n\nCompany: ${payload.companyFields?.map(f => f.id).join(', ')}\nPO: ${payload.purchaseOrderFields?.map(f => f.id).join(', ')}\nVendor: ${payload.vendorFields?.map(f => f.id).join(', ')}\nShipTo: ${payload.shipToFields?.map(f => f.id).join(', ')}\nShipping: requisitioner, shipVia, fob, shippingTerms\nLineItems: itemNumber, description, qty, rate, amount (3 items)\nTotals: subtotal, tax, shipping, other, total\nComments: comments, contactInfo\n\nReturn ONLY valid JSON with field IDs as keys.`\n        }\n      ];\n\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: 'gpt-3.5-turbo',\n          messages,\n          temperature: 1,\n          // Force JSON-only output\n          response_format: { type: 'json_object' },\n          // Allow more output to avoid truncation\n          max_completion_tokens: 3000\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(`OpenAI API error: ${errorData.error?.message || response.statusText}`);\n      }\n\n      const data = await response.json();\n      console.debug('ðŸ§ª OpenAI chat data:', data);\n\n      // Extract content across possible API response shapes\n      const extractContent = (payload) => {\n        const cc = payload?.choices?.[0]?.message?.content;\n        if (typeof cc === 'string' && cc.trim()) return cc;\n        // Some models may return parsed JSON when response_format is json_object\n        const parsedField = payload?.choices?.[0]?.message?.parsed;\n        if (parsedField && typeof parsedField === 'object') return JSON.stringify(parsedField);\n        if (typeof payload?.output_text === 'string' && payload.output_text.trim()) {\n          return payload.output_text;\n        }\n        const outputArray = payload?.output;\n        if (Array.isArray(outputArray) && outputArray.length > 0) {\n          // Search all items and parts for any text\n          for (const item of outputArray) {\n            const parts = item?.content;\n            if (Array.isArray(parts)) {\n              for (const p of parts) {\n                if (typeof p?.text === 'string' && p.text.trim()) return p.text;\n              }\n            }\n          }\n        }\n        const topContent = payload?.content;\n        if (Array.isArray(topContent)) {\n          const textPart = topContent.find(p => typeof p?.text === 'string' && p.text.trim());\n          if (textPart?.text) return textPart.text;\n        }\n        return undefined;\n      };\n\n      let content = extractContent(data);\n      console.debug('ðŸ§ª Extracted content after chat:', typeof content, content?.slice ? content.slice(0, 200) : content);\n      \n      if (!content) {\n        // Fallback to Responses API once\n        const respFallback = await fetch('https://api.openai.com/v1/responses', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${apiKey}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            model: 'gpt-3.5-turbo',\n            // Send structured messages for better adherence\n            input: [\n              { role: 'system', content: messages[0].content },\n              { role: 'user', content: messages[1].content }\n            ],\n            // Force JSON-only output\n            response_format: { type: 'json_object' },\n            max_output_tokens: 1500\n          })\n        });\n\n        if (!respFallback.ok) {\n          const errorData = await respFallback.json();\n          throw new Error(`OpenAI API error: ${errorData.error?.message || respFallback.statusText}`);\n        }\n\n        const dataFallback = await respFallback.json();\n        console.debug('ðŸ§ª OpenAI responses data (fallback):', dataFallback);\n        content = extractContent(dataFallback);\n        console.debug('ðŸ§ª Extracted content after fallback:', typeof content, content?.slice ? content.slice(0, 200) : content);\n      }\n\n      if (!content) {\n        throw new Error('No response content from OpenAI');\n      }\n\n      // Parse the JSON response, tolerate code fences or extra text, and filter to known field IDs\n      try {\n        // Remove possible Markdown code fences\n        let cleaned = content.trim();\n        if (cleaned.startsWith('```')) {\n          cleaned = cleaned.replace(/^```(?:json)?\\s*/i, '').replace(/```$/i, '').trim();\n        }\n\n        let parsed;\n        try {\n          parsed = JSON.parse(cleaned);\n        } catch (innerErr) {\n          // Try extracting the first JSON object if extra prose is present\n          const firstBrace = cleaned.indexOf('{');\n          const lastBrace = cleaned.lastIndexOf('}');\n          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n            const maybeJson = cleaned.slice(firstBrace, lastBrace + 1);\n            parsed = JSON.parse(maybeJson);\n          } else {\n            throw innerErr;\n          }\n        }\n\n        // Build allowlist of known field IDs and a lookup by normalized label\n        const allFields = [\n          ...(payload.companyFields || []),\n          ...(payload.purchaseOrderFields || []),\n          ...(payload.vendorFields || []),\n          ...(payload.shipToFields || []),\n          ...(payload.shippingFields || [])\n        ];\n        const allowedIds = allFields.map(f => f.id);\n        const normalize = (s) => String(s || '')\n          .toLowerCase()\n          .replace(/[`\"'â€™]/g, '')\n          .replace(/\\s+/g, ' ')\n          .trim()\n          .replace(/[^a-z0-9]+/g, '');\n        const labelToId = Object.fromEntries(\n          allFields.map(f => [normalize(f.label || f.id), f.id])\n        );\n\n        const coerceToString = (v) => {\n          if (typeof v === 'string') return v;\n          if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n          if (v && typeof v === 'object') {\n            if (typeof v.value === 'string') return v.value;\n            if (typeof v.text === 'string') return v.text;\n          }\n          return undefined;\n        };\n\n        const suggestions = {};\n        for (const [rawKey, rawVal] of Object.entries(parsed || {})) {\n          const value = coerceToString(rawVal);\n          if (value === undefined) continue;\n\n          // direct id match\n          if (allowedIds.includes(rawKey)) {\n            suggestions[rawKey] = value;\n            continue;\n          }\n\n          // label-based or fuzzy match\n          const normalizedKey = normalize(rawKey);\n          const maybeId = labelToId[normalizedKey];\n          if (maybeId && allowedIds.includes(maybeId)) {\n            suggestions[maybeId] = value;\n          }\n        }\n\n        return { suggestions };\n      } catch (parseError) {\n        console.error('Failed to parse OpenAI response:', content);\n        throw new Error('Invalid JSON response from AI - please try again');\n      }\n    } catch (error) {\n      console.error('OpenAI API call failed:', error);\n      throw error;\n    }\n  }\n\n  return { getFieldSuggestions };\n}\n\n\n"],"mappings":"AAAA;AACA;;AAEA,OAAO,SAASA,aAAaA,CAAA,EAAG;EAC9B,MAAMC,MAAM,GAAGC,OAAO,CAACC,GAAG,CAACC,wBAAwB;EAEnD,eAAeC,mBAAmBA,CAACC,OAAO,EAAE;IAC1C,IAAI,CAACL,MAAM,EAAE;MACX,MAAM,IAAIM,KAAK,CAAC,+EAA+E,CAAC;IAClG;IAEA,IAAI;MAAA,IAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,qBAAA,EAAAC,QAAA;MACF;MACA,MAAMC,QAAQ,GAAG,CACf;QACEC,IAAI,EAAE,QAAQ;QACdC,OAAO,EAAE;AACnB;AACA;AACA;MACQ,CAAC,EACD;QACED,IAAI,EAAE,MAAM;QACZC,OAAO,EAAE;AACnB;AACA,WAFmB,CAAAP,qBAAA,GAERF,OAAO,CAACU,aAAa,cAAAR,qBAAA,uBAArBA,qBAAA,CAAuBS,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AAC3D,MAD2D,CAAAX,qBAAA,GACrDH,OAAO,CAACe,mBAAmB,cAAAZ,qBAAA,uBAA3BA,qBAAA,CAA6BQ,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AAC5D,UAD4D,CAAAV,qBAAA,GAClDJ,OAAO,CAACgB,YAAY,cAAAZ,qBAAA,uBAApBA,qBAAA,CAAsBO,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AACzD,UADyD,CAAAT,qBAAA,GAC/CL,OAAO,CAACiB,YAAY,cAAAZ,qBAAA,uBAApBA,qBAAA,CAAsBM,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC,CAACC,IAAI,CAAC,IAAI,CAAC;AACzD;AACA;AACA;AACA;AACA;AACA;MACQ,CAAC,CACF;MAED,MAAMI,QAAQ,GAAG,MAAMC,KAAK,CAAC,4CAA4C,EAAE;QACzEC,MAAM,EAAE,MAAM;QACdC,OAAO,EAAE;UACP,eAAe,EAAE,UAAU1B,MAAM,EAAE;UACnC,cAAc,EAAE;QAClB,CAAC;QACD2B,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;UACnBC,KAAK,EAAE,eAAe;UACtBlB,QAAQ;UACRmB,WAAW,EAAE,CAAC;UACd;UACAC,eAAe,EAAE;YAAEC,IAAI,EAAE;UAAc,CAAC;UACxC;UACAC,qBAAqB,EAAE;QACzB,CAAC;MACH,CAAC,CAAC;MAEF,IAAI,CAACX,QAAQ,CAACY,EAAE,EAAE;QAAA,IAAAC,gBAAA;QAChB,MAAMC,SAAS,GAAG,MAAMd,QAAQ,CAACe,IAAI,CAAC,CAAC;QACvC,MAAM,IAAIhC,KAAK,CAAC,qBAAqB,EAAA8B,gBAAA,GAAAC,SAAS,CAACE,KAAK,cAAAH,gBAAA,uBAAfA,gBAAA,CAAiBI,OAAO,KAAIjB,QAAQ,CAACkB,UAAU,EAAE,CAAC;MACzF;MAEA,MAAMC,IAAI,GAAG,MAAMnB,QAAQ,CAACe,IAAI,CAAC,CAAC;MAClCK,OAAO,CAACC,KAAK,CAAC,sBAAsB,EAAEF,IAAI,CAAC;;MAE3C;MACA,MAAMG,cAAc,GAAIxC,OAAO,IAAK;QAAA,IAAAyC,gBAAA,EAAAC,iBAAA,EAAAC,qBAAA,EAAAC,iBAAA,EAAAC,kBAAA,EAAAC,qBAAA;QAClC,MAAMC,EAAE,GAAG/C,OAAO,aAAPA,OAAO,wBAAAyC,gBAAA,GAAPzC,OAAO,CAAEgD,OAAO,cAAAP,gBAAA,wBAAAC,iBAAA,GAAhBD,gBAAA,CAAmB,CAAC,CAAC,cAAAC,iBAAA,wBAAAC,qBAAA,GAArBD,iBAAA,CAAuBP,OAAO,cAAAQ,qBAAA,uBAA9BA,qBAAA,CAAgClC,OAAO;QAClD,IAAI,OAAOsC,EAAE,KAAK,QAAQ,IAAIA,EAAE,CAACE,IAAI,CAAC,CAAC,EAAE,OAAOF,EAAE;QAClD;QACA,MAAMG,WAAW,GAAGlD,OAAO,aAAPA,OAAO,wBAAA4C,iBAAA,GAAP5C,OAAO,CAAEgD,OAAO,cAAAJ,iBAAA,wBAAAC,kBAAA,GAAhBD,iBAAA,CAAmB,CAAC,CAAC,cAAAC,kBAAA,wBAAAC,qBAAA,GAArBD,kBAAA,CAAuBV,OAAO,cAAAW,qBAAA,uBAA9BA,qBAAA,CAAgCK,MAAM;QAC1D,IAAID,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE,OAAO3B,IAAI,CAACC,SAAS,CAAC0B,WAAW,CAAC;QACtF,IAAI,QAAOlD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEoD,WAAW,MAAK,QAAQ,IAAIpD,OAAO,CAACoD,WAAW,CAACH,IAAI,CAAC,CAAC,EAAE;UAC1E,OAAOjD,OAAO,CAACoD,WAAW;QAC5B;QACA,MAAMC,WAAW,GAAGrD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAEsD,MAAM;QACnC,IAAIC,KAAK,CAACC,OAAO,CAACH,WAAW,CAAC,IAAIA,WAAW,CAACI,MAAM,GAAG,CAAC,EAAE;UACxD;UACA,KAAK,MAAMC,IAAI,IAAIL,WAAW,EAAE;YAC9B,MAAMM,KAAK,GAAGD,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEjD,OAAO;YAC3B,IAAI8C,KAAK,CAACC,OAAO,CAACG,KAAK,CAAC,EAAE;cACxB,KAAK,MAAMC,CAAC,IAAID,KAAK,EAAE;gBACrB,IAAI,QAAOC,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEC,IAAI,MAAK,QAAQ,IAAID,CAAC,CAACC,IAAI,CAACZ,IAAI,CAAC,CAAC,EAAE,OAAOW,CAAC,CAACC,IAAI;cACjE;YACF;UACF;QACF;QACA,MAAMC,UAAU,GAAG9D,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAES,OAAO;QACnC,IAAI8C,KAAK,CAACC,OAAO,CAACM,UAAU,CAAC,EAAE;UAC7B,MAAMC,QAAQ,GAAGD,UAAU,CAACE,IAAI,CAACJ,CAAC,IAAI,QAAOA,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEC,IAAI,MAAK,QAAQ,IAAID,CAAC,CAACC,IAAI,CAACZ,IAAI,CAAC,CAAC,CAAC;UACnF,IAAIc,QAAQ,aAARA,QAAQ,eAARA,QAAQ,CAAEF,IAAI,EAAE,OAAOE,QAAQ,CAACF,IAAI;QAC1C;QACA,OAAOI,SAAS;MAClB,CAAC;MAED,IAAIxD,OAAO,GAAG+B,cAAc,CAACH,IAAI,CAAC;MAClCC,OAAO,CAACC,KAAK,CAAC,kCAAkC,EAAE,OAAO9B,OAAO,EAAE,CAAAH,QAAA,GAAAG,OAAO,cAAAH,QAAA,eAAPA,QAAA,CAAS4D,KAAK,GAAGzD,OAAO,CAACyD,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,GAAGzD,OAAO,CAAC;MAEnH,IAAI,CAACA,OAAO,EAAE;QAAA,IAAA0D,SAAA;QACZ;QACA,MAAMC,YAAY,GAAG,MAAMjD,KAAK,CAAC,qCAAqC,EAAE;UACtEC,MAAM,EAAE,MAAM;UACdC,OAAO,EAAE;YACP,eAAe,EAAE,UAAU1B,MAAM,EAAE;YACnC,cAAc,EAAE;UAClB,CAAC;UACD2B,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;YACnBC,KAAK,EAAE,eAAe;YACtB;YACA4C,KAAK,EAAE,CACL;cAAE7D,IAAI,EAAE,QAAQ;cAAEC,OAAO,EAAEF,QAAQ,CAAC,CAAC,CAAC,CAACE;YAAQ,CAAC,EAChD;cAAED,IAAI,EAAE,MAAM;cAAEC,OAAO,EAAEF,QAAQ,CAAC,CAAC,CAAC,CAACE;YAAQ,CAAC,CAC/C;YACD;YACAkB,eAAe,EAAE;cAAEC,IAAI,EAAE;YAAc,CAAC;YACxC0C,iBAAiB,EAAE;UACrB,CAAC;QACH,CAAC,CAAC;QAEF,IAAI,CAACF,YAAY,CAACtC,EAAE,EAAE;UAAA,IAAAyC,iBAAA;UACpB,MAAMvC,SAAS,GAAG,MAAMoC,YAAY,CAACnC,IAAI,CAAC,CAAC;UAC3C,MAAM,IAAIhC,KAAK,CAAC,qBAAqB,EAAAsE,iBAAA,GAAAvC,SAAS,CAACE,KAAK,cAAAqC,iBAAA,uBAAfA,iBAAA,CAAiBpC,OAAO,KAAIiC,YAAY,CAAChC,UAAU,EAAE,CAAC;QAC7F;QAEA,MAAMoC,YAAY,GAAG,MAAMJ,YAAY,CAACnC,IAAI,CAAC,CAAC;QAC9CK,OAAO,CAACC,KAAK,CAAC,sCAAsC,EAAEiC,YAAY,CAAC;QACnE/D,OAAO,GAAG+B,cAAc,CAACgC,YAAY,CAAC;QACtClC,OAAO,CAACC,KAAK,CAAC,sCAAsC,EAAE,OAAO9B,OAAO,EAAE,CAAA0D,SAAA,GAAA1D,OAAO,cAAA0D,SAAA,eAAPA,SAAA,CAASD,KAAK,GAAGzD,OAAO,CAACyD,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,GAAGzD,OAAO,CAAC;MACzH;MAEA,IAAI,CAACA,OAAO,EAAE;QACZ,MAAM,IAAIR,KAAK,CAAC,iCAAiC,CAAC;MACpD;;MAEA;MACA,IAAI;QACF;QACA,IAAIwE,OAAO,GAAGhE,OAAO,CAACwC,IAAI,CAAC,CAAC;QAC5B,IAAIwB,OAAO,CAACC,UAAU,CAAC,KAAK,CAAC,EAAE;UAC7BD,OAAO,GAAGA,OAAO,CAACE,OAAO,CAAC,mBAAmB,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC1B,IAAI,CAAC,CAAC;QAChF;QAEA,IAAIE,MAAM;QACV,IAAI;UACFA,MAAM,GAAG5B,IAAI,CAACqD,KAAK,CAACH,OAAO,CAAC;QAC9B,CAAC,CAAC,OAAOI,QAAQ,EAAE;UACjB;UACA,MAAMC,UAAU,GAAGL,OAAO,CAACM,OAAO,CAAC,GAAG,CAAC;UACvC,MAAMC,SAAS,GAAGP,OAAO,CAACQ,WAAW,CAAC,GAAG,CAAC;UAC1C,IAAIH,UAAU,KAAK,CAAC,CAAC,IAAIE,SAAS,KAAK,CAAC,CAAC,IAAIA,SAAS,GAAGF,UAAU,EAAE;YACnE,MAAMI,SAAS,GAAGT,OAAO,CAACP,KAAK,CAACY,UAAU,EAAEE,SAAS,GAAG,CAAC,CAAC;YAC1D7B,MAAM,GAAG5B,IAAI,CAACqD,KAAK,CAACM,SAAS,CAAC;UAChC,CAAC,MAAM;YACL,MAAML,QAAQ;UAChB;QACF;;QAEA;QACA,MAAMM,SAAS,GAAG,CAChB,IAAInF,OAAO,CAACU,aAAa,IAAI,EAAE,CAAC,EAChC,IAAIV,OAAO,CAACe,mBAAmB,IAAI,EAAE,CAAC,EACtC,IAAIf,OAAO,CAACgB,YAAY,IAAI,EAAE,CAAC,EAC/B,IAAIhB,OAAO,CAACiB,YAAY,IAAI,EAAE,CAAC,EAC/B,IAAIjB,OAAO,CAACoF,cAAc,IAAI,EAAE,CAAC,CAClC;QACD,MAAMC,UAAU,GAAGF,SAAS,CAACxE,GAAG,CAACC,CAAC,IAAIA,CAAC,CAACC,EAAE,CAAC;QAC3C,MAAMyE,SAAS,GAAIC,CAAC,IAAKC,MAAM,CAACD,CAAC,IAAI,EAAE,CAAC,CACrCE,WAAW,CAAC,CAAC,CACbd,OAAO,CAAC,SAAS,EAAE,EAAE,CAAC,CACtBA,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CACpB1B,IAAI,CAAC,CAAC,CACN0B,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC;QAC7B,MAAMe,SAAS,GAAGC,MAAM,CAACC,WAAW,CAClCT,SAAS,CAACxE,GAAG,CAACC,CAAC,IAAI,CAAC0E,SAAS,CAAC1E,CAAC,CAACiF,KAAK,IAAIjF,CAAC,CAACC,EAAE,CAAC,EAAED,CAAC,CAACC,EAAE,CAAC,CACvD,CAAC;QAED,MAAMiF,cAAc,GAAIC,CAAC,IAAK;UAC5B,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOA,CAAC;UACnC,IAAI,OAAOA,CAAC,KAAK,QAAQ,IAAI,OAAOA,CAAC,KAAK,SAAS,EAAE,OAAOP,MAAM,CAACO,CAAC,CAAC;UACrE,IAAIA,CAAC,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE;YAC9B,IAAI,OAAOA,CAAC,CAACC,KAAK,KAAK,QAAQ,EAAE,OAAOD,CAAC,CAACC,KAAK;YAC/C,IAAI,OAAOD,CAAC,CAAClC,IAAI,KAAK,QAAQ,EAAE,OAAOkC,CAAC,CAAClC,IAAI;UAC/C;UACA,OAAOI,SAAS;QAClB,CAAC;QAED,MAAMgC,WAAW,GAAG,CAAC,CAAC;QACtB,KAAK,MAAM,CAACC,MAAM,EAAEC,MAAM,CAAC,IAAIR,MAAM,CAACS,OAAO,CAACjD,MAAM,IAAI,CAAC,CAAC,CAAC,EAAE;UAC3D,MAAM6C,KAAK,GAAGF,cAAc,CAACK,MAAM,CAAC;UACpC,IAAIH,KAAK,KAAK/B,SAAS,EAAE;;UAEzB;UACA,IAAIoB,UAAU,CAACgB,QAAQ,CAACH,MAAM,CAAC,EAAE;YAC/BD,WAAW,CAACC,MAAM,CAAC,GAAGF,KAAK;YAC3B;UACF;;UAEA;UACA,MAAMM,aAAa,GAAGhB,SAAS,CAACY,MAAM,CAAC;UACvC,MAAMK,OAAO,GAAGb,SAAS,CAACY,aAAa,CAAC;UACxC,IAAIC,OAAO,IAAIlB,UAAU,CAACgB,QAAQ,CAACE,OAAO,CAAC,EAAE;YAC3CN,WAAW,CAACM,OAAO,CAAC,GAAGP,KAAK;UAC9B;QACF;QAEA,OAAO;UAAEC;QAAY,CAAC;MACxB,CAAC,CAAC,OAAOO,UAAU,EAAE;QACnBlE,OAAO,CAACJ,KAAK,CAAC,kCAAkC,EAAEzB,OAAO,CAAC;QAC1D,MAAM,IAAIR,KAAK,CAAC,kDAAkD,CAAC;MACrE;IACF,CAAC,CAAC,OAAOiC,KAAK,EAAE;MACdI,OAAO,CAACJ,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;MAC/C,MAAMA,KAAK;IACb;EACF;EAEA,OAAO;IAAEnC;EAAoB,CAAC;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}