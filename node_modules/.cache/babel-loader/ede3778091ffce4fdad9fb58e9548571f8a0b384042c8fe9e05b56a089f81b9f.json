{"ast":null,"code":"// AI provider hook - uses ChatGPT API directly\n// Set REACT_APP_OPENAI_API_KEY in your .env file to keep the key secure\n\nexport function useAIProvider() {\n  const apiKey = process.env.REACT_APP_OPENAI_API_KEY;\n  async function getFieldSuggestions(payload) {\n    if (!apiKey) {\n      throw new Error('OpenAI API key not configured. Set REACT_APP_OPENAI_API_KEY in your .env file');\n    }\n    try {\n      var _payload$companyField, _payload$purchaseOrde, _payload$vendorFields, _payload$shipToFields;\n      // Build reusable messages for both chat and fallback calls\n      const messages = [{\n        role: 'system',\n        content: `You are a helpful assistant that fills out purchase order forms. \n              Analyze the provided fields and return realistic, business-appropriate values.\n              Return ONLY a JSON object with field IDs as keys and suggested values as strings.\n              Example: {\"company-name\": \"Acme Corporation\", \"po-number\": \"PO-2024-001\"}`\n      }, {\n        role: 'user',\n        content: `Please fill out these purchase order fields with realistic business data:\n              Company Fields: ${(_payload$companyField = payload.companyFields) === null || _payload$companyField === void 0 ? void 0 : _payload$companyField.map(f => `${f.id}: ${f.label}`).join(', ')}\n              Purchase Order Fields: ${(_payload$purchaseOrde = payload.purchaseOrderFields) === null || _payload$purchaseOrde === void 0 ? void 0 : _payload$purchaseOrde.map(f => `${f.id}: ${f.label}`).join(', ')}\n              Vendor Fields: ${(_payload$vendorFields = payload.vendorFields) === null || _payload$vendorFields === void 0 ? void 0 : _payload$vendorFields.map(f => `${f.id}: ${f.label}`).join(', ')}\n              Ship To Fields: ${(_payload$shipToFields = payload.shipToFields) === null || _payload$shipToFields === void 0 ? void 0 : _payload$shipToFields.map(f => `${f.id}: ${f.label}`).join(', ')}\n              \n              Return only valid JSON with field IDs as keys.`\n      }];\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiKey}`,\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          model: 'gpt-5',\n          messages,\n          temperature: 1,\n          max_completion_tokens: 1000\n        })\n      });\n      if (!response.ok) {\n        var _errorData$error;\n        const errorData = await response.json();\n        throw new Error(`OpenAI API error: ${((_errorData$error = errorData.error) === null || _errorData$error === void 0 ? void 0 : _errorData$error.message) || response.statusText}`);\n      }\n      const data = await response.json();\n\n      // Extract content across possible API response shapes\n      const extractContent = payload => {\n        var _payload$choices, _payload$choices$, _payload$choices$$mes;\n        const cc = payload === null || payload === void 0 ? void 0 : (_payload$choices = payload.choices) === null || _payload$choices === void 0 ? void 0 : (_payload$choices$ = _payload$choices[0]) === null || _payload$choices$ === void 0 ? void 0 : (_payload$choices$$mes = _payload$choices$.message) === null || _payload$choices$$mes === void 0 ? void 0 : _payload$choices$$mes.content;\n        if (cc) return cc;\n        if (typeof (payload === null || payload === void 0 ? void 0 : payload.output_text) === 'string' && payload.output_text.trim()) {\n          return payload.output_text;\n        }\n        const outputArray = payload === null || payload === void 0 ? void 0 : payload.output;\n        if (Array.isArray(outputArray) && outputArray.length > 0) {\n          var _outputArray$;\n          const parts = (_outputArray$ = outputArray[0]) === null || _outputArray$ === void 0 ? void 0 : _outputArray$.content;\n          if (Array.isArray(parts)) {\n            const textPart = parts.find(p => typeof (p === null || p === void 0 ? void 0 : p.text) === 'string');\n            if (textPart !== null && textPart !== void 0 && textPart.text) return textPart.text;\n          }\n        }\n        const topContent = payload === null || payload === void 0 ? void 0 : payload.content;\n        if (Array.isArray(topContent)) {\n          const textPart = topContent.find(p => typeof (p === null || p === void 0 ? void 0 : p.text) === 'string');\n          if (textPart !== null && textPart !== void 0 && textPart.text) return textPart.text;\n        }\n        return undefined;\n      };\n      let content = extractContent(data);\n      if (!content) {\n        // Fallback to Responses API once\n        const combinedPrompt = `${messages[0].content}\\n\\n${messages[1].content}`;\n        const respFallback = await fetch('https://api.openai.com/v1/responses', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${apiKey}`,\n            'Content-Type': 'application/json'\n          },\n          body: JSON.stringify({\n            model: 'gpt-5',\n            input: combinedPrompt,\n            max_output_tokens: 1000\n          })\n        });\n        if (!respFallback.ok) {\n          var _errorData$error2;\n          const errorData = await respFallback.json();\n          throw new Error(`OpenAI API error: ${((_errorData$error2 = errorData.error) === null || _errorData$error2 === void 0 ? void 0 : _errorData$error2.message) || respFallback.statusText}`);\n        }\n        const dataFallback = await respFallback.json();\n        content = extractContent(dataFallback);\n      }\n      if (!content) {\n        throw new Error('No response content from OpenAI');\n      }\n\n      // Parse the JSON response, tolerate code fences or extra text, and filter to known field IDs\n      try {\n        // Remove possible Markdown code fences\n        let cleaned = content.trim();\n        if (cleaned.startsWith('```')) {\n          cleaned = cleaned.replace(/^```(?:json)?\\s*/i, '').replace(/```$/i, '').trim();\n        }\n        let parsed;\n        try {\n          parsed = JSON.parse(cleaned);\n        } catch (innerErr) {\n          // Try extracting the first JSON object if extra prose is present\n          const firstBrace = cleaned.indexOf('{');\n          const lastBrace = cleaned.lastIndexOf('}');\n          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n            const maybeJson = cleaned.slice(firstBrace, lastBrace + 1);\n            parsed = JSON.parse(maybeJson);\n          } else {\n            throw innerErr;\n          }\n        }\n\n        // Build allowlist of known field IDs and a lookup by normalized label\n        const allFields = [...(payload.companyFields || []), ...(payload.purchaseOrderFields || []), ...(payload.vendorFields || []), ...(payload.shipToFields || [])];\n        const allowedIds = allFields.map(f => f.id);\n        const normalize = s => String(s || '').toLowerCase().replace(/[`\"'’]/g, '').replace(/\\s+/g, ' ').trim().replace(/[^a-z0-9]+/g, '');\n        const labelToId = Object.fromEntries(allFields.map(f => [normalize(f.label || f.id), f.id]));\n        const coerceToString = v => {\n          if (typeof v === 'string') return v;\n          if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n          if (v && typeof v === 'object') {\n            if (typeof v.value === 'string') return v.value;\n            if (typeof v.text === 'string') return v.text;\n          }\n          return undefined;\n        };\n        const suggestions = {};\n        for (const [rawKey, rawVal] of Object.entries(parsed || {})) {\n          const value = coerceToString(rawVal);\n          if (value === undefined) continue;\n\n          // direct id match\n          if (allowedIds.includes(rawKey)) {\n            suggestions[rawKey] = value;\n            continue;\n          }\n\n          // label-based or fuzzy match\n          const normalizedKey = normalize(rawKey);\n          const maybeId = labelToId[normalizedKey];\n          if (maybeId && allowedIds.includes(maybeId)) {\n            suggestions[maybeId] = value;\n          }\n        }\n        return {\n          suggestions\n        };\n      } catch (parseError) {\n        console.error('Failed to parse OpenAI response:', content);\n        throw new Error('Invalid JSON response from AI - please try again');\n      }\n    } catch (error) {\n      console.error('OpenAI API call failed:', error);\n      throw error;\n    }\n  }\n  return {\n    getFieldSuggestions\n  };\n}","map":{"version":3,"names":["useAIProvider","apiKey","process","env","REACT_APP_OPENAI_API_KEY","getFieldSuggestions","payload","Error","_payload$companyField","_payload$purchaseOrde","_payload$vendorFields","_payload$shipToFields","messages","role","content","companyFields","map","f","id","label","join","purchaseOrderFields","vendorFields","shipToFields","response","fetch","method","headers","body","JSON","stringify","model","temperature","max_completion_tokens","ok","_errorData$error","errorData","json","error","message","statusText","data","extractContent","_payload$choices","_payload$choices$","_payload$choices$$mes","cc","choices","output_text","trim","outputArray","output","Array","isArray","length","_outputArray$","parts","textPart","find","p","text","topContent","undefined","combinedPrompt","respFallback","input","max_output_tokens","_errorData$error2","dataFallback","cleaned","startsWith","replace","parsed","parse","innerErr","firstBrace","indexOf","lastBrace","lastIndexOf","maybeJson","slice","allFields","allowedIds","normalize","s","String","toLowerCase","labelToId","Object","fromEntries","coerceToString","v","value","suggestions","rawKey","rawVal","entries","includes","normalizedKey","maybeId","parseError","console"],"sources":["/Users/waleed/Documents/GitHub/Cadbury3/src/hooks/useAIProvider.js"],"sourcesContent":["// AI provider hook - uses ChatGPT API directly\n// Set REACT_APP_OPENAI_API_KEY in your .env file to keep the key secure\n\nexport function useAIProvider() {\n  const apiKey = process.env.REACT_APP_OPENAI_API_KEY;\n\n  async function getFieldSuggestions(payload) {\n    if (!apiKey) {\n      throw new Error('OpenAI API key not configured. Set REACT_APP_OPENAI_API_KEY in your .env file');\n    }\n\n    try {\n      // Build reusable messages for both chat and fallback calls\n      const messages = [\n        {\n          role: 'system',\n          content: `You are a helpful assistant that fills out purchase order forms. \n              Analyze the provided fields and return realistic, business-appropriate values.\n              Return ONLY a JSON object with field IDs as keys and suggested values as strings.\n              Example: {\"company-name\": \"Acme Corporation\", \"po-number\": \"PO-2024-001\"}`\n        },\n        {\n          role: 'user',\n          content: `Please fill out these purchase order fields with realistic business data:\n              Company Fields: ${payload.companyFields?.map(f => `${f.id}: ${f.label}`).join(', ')}\n              Purchase Order Fields: ${payload.purchaseOrderFields?.map(f => `${f.id}: ${f.label}`).join(', ')}\n              Vendor Fields: ${payload.vendorFields?.map(f => `${f.id}: ${f.label}`).join(', ')}\n              Ship To Fields: ${payload.shipToFields?.map(f => `${f.id}: ${f.label}`).join(', ')}\n              \n              Return only valid JSON with field IDs as keys.`\n        }\n      ];\n\n      const response = await fetch('https://api.openai.com/v1/chat/completions', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model: 'gpt-5',\n          messages,\n          temperature: 1,\n          max_completion_tokens: 1000\n        })\n      });\n\n      if (!response.ok) {\n        const errorData = await response.json();\n        throw new Error(`OpenAI API error: ${errorData.error?.message || response.statusText}`);\n      }\n\n      const data = await response.json();\n\n      // Extract content across possible API response shapes\n      const extractContent = (payload) => {\n        const cc = payload?.choices?.[0]?.message?.content;\n        if (cc) return cc;\n        if (typeof payload?.output_text === 'string' && payload.output_text.trim()) {\n          return payload.output_text;\n        }\n        const outputArray = payload?.output;\n        if (Array.isArray(outputArray) && outputArray.length > 0) {\n          const parts = outputArray[0]?.content;\n          if (Array.isArray(parts)) {\n            const textPart = parts.find(p => typeof p?.text === 'string');\n            if (textPart?.text) return textPart.text;\n          }\n        }\n        const topContent = payload?.content;\n        if (Array.isArray(topContent)) {\n          const textPart = topContent.find(p => typeof p?.text === 'string');\n          if (textPart?.text) return textPart.text;\n        }\n        return undefined;\n      };\n\n      let content = extractContent(data);\n      \n      if (!content) {\n        // Fallback to Responses API once\n        const combinedPrompt = `${messages[0].content}\\n\\n${messages[1].content}`;\n        const respFallback = await fetch('https://api.openai.com/v1/responses', {\n          method: 'POST',\n          headers: {\n            'Authorization': `Bearer ${apiKey}`,\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            model: 'gpt-5',\n            input: combinedPrompt,\n            max_output_tokens: 1000\n          })\n        });\n\n        if (!respFallback.ok) {\n          const errorData = await respFallback.json();\n          throw new Error(`OpenAI API error: ${errorData.error?.message || respFallback.statusText}`);\n        }\n\n        const dataFallback = await respFallback.json();\n        content = extractContent(dataFallback);\n      }\n\n      if (!content) {\n        throw new Error('No response content from OpenAI');\n      }\n\n      // Parse the JSON response, tolerate code fences or extra text, and filter to known field IDs\n      try {\n        // Remove possible Markdown code fences\n        let cleaned = content.trim();\n        if (cleaned.startsWith('```')) {\n          cleaned = cleaned.replace(/^```(?:json)?\\s*/i, '').replace(/```$/i, '').trim();\n        }\n\n        let parsed;\n        try {\n          parsed = JSON.parse(cleaned);\n        } catch (innerErr) {\n          // Try extracting the first JSON object if extra prose is present\n          const firstBrace = cleaned.indexOf('{');\n          const lastBrace = cleaned.lastIndexOf('}');\n          if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n            const maybeJson = cleaned.slice(firstBrace, lastBrace + 1);\n            parsed = JSON.parse(maybeJson);\n          } else {\n            throw innerErr;\n          }\n        }\n\n        // Build allowlist of known field IDs and a lookup by normalized label\n        const allFields = [\n          ...(payload.companyFields || []),\n          ...(payload.purchaseOrderFields || []),\n          ...(payload.vendorFields || []),\n          ...(payload.shipToFields || [])\n        ];\n        const allowedIds = allFields.map(f => f.id);\n        const normalize = (s) => String(s || '')\n          .toLowerCase()\n          .replace(/[`\"'’]/g, '')\n          .replace(/\\s+/g, ' ')\n          .trim()\n          .replace(/[^a-z0-9]+/g, '');\n        const labelToId = Object.fromEntries(\n          allFields.map(f => [normalize(f.label || f.id), f.id])\n        );\n\n        const coerceToString = (v) => {\n          if (typeof v === 'string') return v;\n          if (typeof v === 'number' || typeof v === 'boolean') return String(v);\n          if (v && typeof v === 'object') {\n            if (typeof v.value === 'string') return v.value;\n            if (typeof v.text === 'string') return v.text;\n          }\n          return undefined;\n        };\n\n        const suggestions = {};\n        for (const [rawKey, rawVal] of Object.entries(parsed || {})) {\n          const value = coerceToString(rawVal);\n          if (value === undefined) continue;\n\n          // direct id match\n          if (allowedIds.includes(rawKey)) {\n            suggestions[rawKey] = value;\n            continue;\n          }\n\n          // label-based or fuzzy match\n          const normalizedKey = normalize(rawKey);\n          const maybeId = labelToId[normalizedKey];\n          if (maybeId && allowedIds.includes(maybeId)) {\n            suggestions[maybeId] = value;\n          }\n        }\n\n        return { suggestions };\n      } catch (parseError) {\n        console.error('Failed to parse OpenAI response:', content);\n        throw new Error('Invalid JSON response from AI - please try again');\n      }\n    } catch (error) {\n      console.error('OpenAI API call failed:', error);\n      throw error;\n    }\n  }\n\n  return { getFieldSuggestions };\n}\n\n\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}